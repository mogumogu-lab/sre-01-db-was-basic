# SRE-01 부하테스트 결과 정리

## 실험 환경

- 테스트 일시: 2025-07-20
- 서버 사양: AMD Ryzen 3500, 48GB RAM, Ubuntu 24.04
- 서비스 구성: WAS(Fastify, Node.js) + PostgreSQL(Docker)
- k6 버전: v1.1.0

## 테스트 시나리오

- VU: 1000, 2000 / Duration: 20s, 30s
- 요청 종류: CRUD (POST, GET, PUT, DELETE)
- 테스트 스크립트: [loadtest.js](./loadtest.js)


## 부하테스트 주요 결과

### [WAS 병목 구간]
- 1000 VU
  - avg: 20ms, p95: 40ms, max: 896ms (에러 없음)
- 2000 VU
  - avg: 460ms, p95: 830ms, max: 2.1s (에러 없음)

#### **해석**
- 1000 VU까지는 응답속도/에러율 매우 안정적
- 2000 VU 부터 avg/p95 응답속도가 0.5~0.8초로 급격히 증가 (명확한 WAS 병목 도달)

## 모니터링/판단 기준
- p95 500ms 이상: “관심 구간”, 1초 이상: “위험 구간”
- 에러율 1% 이상: 장애로 간주


### [DB 병목 실험]
- **100만 row bulk insert(POST /expensive/insert) + 대량 select(GET /expensive/select) + 전체 delete**
- VU 1~2로 반복 실험:  
  - avg insert/select 1.3~7.1초 (컨테이너 CPU 70~200% 이상 폭등)
  - 동시에 2 VU 이상일 때 DB 락 경합/대기열 심화, 순간적으로 서버 hang 가능성 확인
  - 실제로 DB가 먹통까지 가진 않았으나, 성능 저하 및 부하 급증 현상 발생
- 락 경합(동일 row에 다수 update) 실험 시, 커넥션 대기/지연/타임아웃 경험

### [락 경합(Lock Contention) 실험]
- **동일 row(예: id=1)에 다수 VU가 동시에 update 요청**
  - Fastify: `PUT /items/stress/:id` 엔드포인트 활용  
  - k6: 여러 VU가 `/items/stress/1`로 반복 update 시도
- **결과**
  - 락 경합이 발생하면서 커넥션 대기/지연/timeout/transaction aborted 현상 다수 발생
  - 동시에 update가 몰릴 때, 일부 요청은 즉시 완료되지만 나머지는 대기/실패
  - DB가 완전히 먹통까지 가진 않았으나, 성능 저하와 타임아웃 현상 명확히 관찰

#### **해석**
- 락 경합 상황에서 DB가 쉽게 병목, 대기열 증가, 장애로 이어질 수 있음
- 실무에서는 row-level lock, 트랜잭션/쿼리/설계 개선 필수
- 여러 명이 동시에 같은 row/테이블 집계·수정하면 실서비스 장애와 직결


## 모니터링/판단 기준
- p95 500ms 이상: “관심 구간”, 1초 이상: “위험 구간”
- 에러율 1% 이상: 장애로 간주
- 컨테이너 CPU/메모리 80~90% 이상 또는 락 경합/대기열 발생 시 실시간 모니터링 필요


## 개선점/추가실험 계획
- DB 병목 유발, 쿼리 복잡화, 대량 row 실험
- 구조: 다중 WAS, DB read replica 실험, batch insert, 캐시 도입 등
- 락 경합/데드락/트랜잭션 설계 실험 추가
- 복잡 쿼리, 인덱스 튜닝, 커넥션 풀 제한, failover 등 다양한 장애 상황 대응 실험


## 참고 스크린샷/그래프
![k6 report](./k6-report.png)

---

### **실무 코멘트**
> 컨테이너 실험 환경 덕분에 장애/병목 상황을 언제든 반복, 분석, 복구 가능함.  
> 실전에서는 “죽이지 않고 빠르게 회복”하는 구조(스케일아웃/Failover/DB 튜닝)가 핵심.
> 락 경합/대량 집계/동시 update가 실서비스 장애의 가장 흔한 원인 중 하나임을 실험으로도 확인함.